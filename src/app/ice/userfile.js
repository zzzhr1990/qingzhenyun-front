// **********************************************************************
//
// Copyright (c) 2003-2017 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.7.0
//
// <auto-generated>
//
// Generated from file `userfile.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

(function(module, require, exports)
{
    const Ice = require("ice").Ice;
    const _ModuleRegistry = Ice._ModuleRegistry;
    const common = require("./common").common;
    const Slice = Ice.Slice;

    let userfile = _ModuleRegistry.module("userfile");

    userfile.FileOperationException = class extends common.CommonRpcException
    {
        constructor(innerCode, innerMessage, fileType = 0, _cause = "")
        {
            super(innerCode, innerMessage, _cause);
            this.fileType = fileType;
        }

        static get _parent()
        {
            return common.CommonRpcException;
        }

        static get _id()
        {
            return "::userfile::FileOperationException";
        }

        _mostDerivedType()
        {
            return userfile.FileOperationException;
        }

        _writeMemberImpl(ostr)
        {
            ostr.writeInt(this.fileType);
        }

        _readMemberImpl(istr)
        {
            this.fileType = istr.readInt();
        }
    };

    const iceC_userfile_UserFileResponse_ids = [
        "::Ice::Object",
        "::userfile::UserFileResponse"
    ];

    userfile.UserFileResponse = class extends Ice.Value
    {
        constructor(uuid = "", storeId = "", userId = new Ice.Long(0, 0), pathId = "", path = "", size = new Ice.Long(0, 0), parent = "", mime = "", type = 0, atime = new Ice.Long(0, 0), mtime = new Ice.Long(0, 0), ctime = new Ice.Long(0, 0), alias = "", from = 0, name = "", ext = "", preview = 0, flag = 0, recycle = 0)
        {
            super();
            this.uuid = uuid;
            this.storeId = storeId;
            this.userId = userId;
            this.pathId = pathId;
            this.path = path;
            this.size = size;
            this.parent = parent;
            this.mime = mime;
            this.type = type;
            this.atime = atime;
            this.mtime = mtime;
            this.ctime = ctime;
            this.alias = alias;
            this.from = from;
            this.name = name;
            this.ext = ext;
            this.preview = preview;
            this.flag = flag;
            this.recycle = recycle;
        }

        _iceWriteMemberImpl(ostr)
        {
            ostr.writeString(this.uuid);
            ostr.writeString(this.storeId);
            ostr.writeLong(this.userId);
            ostr.writeString(this.pathId);
            ostr.writeString(this.path);
            ostr.writeLong(this.size);
            ostr.writeString(this.parent);
            ostr.writeString(this.mime);
            ostr.writeInt(this.type);
            ostr.writeLong(this.atime);
            ostr.writeLong(this.mtime);
            ostr.writeLong(this.ctime);
            ostr.writeString(this.alias);
            ostr.writeInt(this.from);
            ostr.writeString(this.name);
            ostr.writeString(this.ext);
            ostr.writeInt(this.preview);
            ostr.writeInt(this.flag);
            ostr.writeInt(this.recycle);
        }

        _iceReadMemberImpl(istr)
        {
            this.uuid = istr.readString();
            this.storeId = istr.readString();
            this.userId = istr.readLong();
            this.pathId = istr.readString();
            this.path = istr.readString();
            this.size = istr.readLong();
            this.parent = istr.readString();
            this.mime = istr.readString();
            this.type = istr.readInt();
            this.atime = istr.readLong();
            this.mtime = istr.readLong();
            this.ctime = istr.readLong();
            this.alias = istr.readString();
            this.from = istr.readInt();
            this.name = istr.readString();
            this.ext = istr.readString();
            this.preview = istr.readInt();
            this.flag = istr.readInt();
            this.recycle = istr.readInt();
        }
    };

    Slice.defineValue(userfile.UserFileResponse, iceC_userfile_UserFileResponse_ids[1], false);

    userfile.UserFileResponseDisp = class extends Ice.Object
    {
    };

    Slice.defineOperations(userfile.UserFileResponseDisp, undefined, iceC_userfile_UserFileResponse_ids, 1);

    Slice.defineSequence(userfile, "UserFileResponseListHelper", "Ice.ObjectHelper", false, "userfile.UserFileResponse");

    const iceC_userfile_UserFilePageResponse_ids = [
        "::Ice::Object",
        "::common::CommonPage",
        "::userfile::UserFilePageResponse"
    ];

    userfile.UserFilePageResponse = class extends common.CommonPage
    {
        constructor(page, pageSize, totalCount, totalPage, path = null, info = null)
        {
            super(page, pageSize, totalCount, totalPage);
            this.path = path;
            this.info = info;
        }

        _iceWriteMemberImpl(ostr)
        {
            userfile.UserFileResponseListHelper.write(ostr, this.path);
            ostr.writeValue(this.info);
        }

        _iceReadMemberImpl(istr)
        {
            this.path = userfile.UserFileResponseListHelper.read(istr);
            istr.readValue(obj => this.info = obj, userfile.UserFileResponse);
        }
    };

    Slice.defineValue(userfile.UserFilePageResponse, iceC_userfile_UserFilePageResponse_ids[2], false);

    userfile.UserFilePageResponseDisp = class extends common.CommonPageDisp
    {
    };

    Slice.defineOperations(userfile.UserFilePageResponseDisp, undefined, iceC_userfile_UserFilePageResponse_ids, 2);

    userfile.UserOfflineResponse = class
    {
        constructor(userId = new Ice.Long(0, 0), taskHash = "", path = "", name = "", files = "", createTime = new Ice.Long(0, 0), uuid = "", progress = 0, status = 0)
        {
            this.userId = userId;
            this.taskHash = taskHash;
            this.path = path;
            this.name = name;
            this.files = files;
            this.createTime = createTime;
            this.uuid = uuid;
            this.progress = progress;
            this.status = status;
        }

        _write(ostr)
        {
            ostr.writeLong(this.userId);
            ostr.writeString(this.taskHash);
            ostr.writeString(this.path);
            ostr.writeString(this.name);
            ostr.writeString(this.files);
            ostr.writeLong(this.createTime);
            ostr.writeString(this.uuid);
            ostr.writeInt(this.progress);
            ostr.writeInt(this.status);
        }

        _read(istr)
        {
            this.userId = istr.readLong();
            this.taskHash = istr.readString();
            this.path = istr.readString();
            this.name = istr.readString();
            this.files = istr.readString();
            this.createTime = istr.readLong();
            this.uuid = istr.readString();
            this.progress = istr.readInt();
            this.status = istr.readInt();
        }

        static get minWireSize()
        {
            return  29;
        }
    };

    Slice.defineStruct(userfile.UserOfflineResponse, true, true);

    Slice.defineSequence(userfile, "UserOfflineResponseListHelper", "userfile.UserOfflineResponse", false);

    const iceC_userfile_UserOfflinePageResponse_ids = [
        "::Ice::Object",
        "::common::CommonPage",
        "::userfile::UserOfflinePageResponse"
    ];

    userfile.UserOfflinePageResponse = class extends common.CommonPage
    {
        constructor(page, pageSize, totalCount, totalPage, list = null)
        {
            super(page, pageSize, totalCount, totalPage);
            this.list = list;
        }

        _iceWriteMemberImpl(ostr)
        {
            userfile.UserOfflineResponseListHelper.write(ostr, this.list);
        }

        _iceReadMemberImpl(istr)
        {
            this.list = userfile.UserOfflineResponseListHelper.read(istr);
        }
    };

    Slice.defineValue(userfile.UserOfflinePageResponse, iceC_userfile_UserOfflinePageResponse_ids[2], false);

    userfile.UserOfflinePageResponseDisp = class extends common.CommonPageDisp
    {
    };

    Slice.defineOperations(userfile.UserOfflinePageResponseDisp, undefined, iceC_userfile_UserOfflinePageResponse_ids, 2);

    const iceC_userfile_UserFileServiceHandler_ids = [
        "::Ice::Object",
        "::userfile::UserFileServiceHandler"
    ];

    userfile.UserFileServiceHandler = class extends Ice.Object
    {
    };

    userfile.UserFileServiceHandlerPrx = class extends Ice.ObjectPrx
    {
    };

    Slice.defineOperations(userfile.UserFileServiceHandler, userfile.UserFileServiceHandlerPrx, iceC_userfile_UserFileServiceHandler_ids, 1,
    {
        "removeOfflineTask": [, , , , [3], [[4], ["common.StringListHelper"]], ,
        [
            userfile.FileOperationException
        ], , ],
        "listOfflinePage": [, , , , ["userfile.UserOfflinePageResponse", true], [[4], [3], [3], [3]], ,
        [
            userfile.FileOperationException
        ], , true],
        "createOfflineTask": [, , , , [userfile.UserOfflineResponse], [[4], [7], [7], [7], [7], [7]], ,
        [
            userfile.FileOperationException
        ], , ],
        "fetchUserOfflineTask": [, , , , ["userfile.UserOfflineResponseListHelper"], [[7]], , , , ],
        "createDirectory": [, , , , ["userfile.UserFileResponse", true], [[4], [7], [7], [7], [1]], ,
        [
            userfile.FileOperationException
        ], , true],
        "get": [, , , , ["userfile.UserFileResponse", true], [[4], [7], [7]], ,
        [
            userfile.FileOperationException
        ], , true],
        "listDirectoryPage": [, , , , ["userfile.UserFilePageResponse", true], [[4], [7], [7], [3], [3], [3], [3], [3]], ,
        [
            userfile.FileOperationException
        ], , true]
    });
    exports.userfile = userfile;
}
(typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? module : undefined,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? require : this.Ice._require,
 typeof(global) !== "undefined" && typeof(global.process) !== "undefined" ? exports : this));
